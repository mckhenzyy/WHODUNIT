# from flask import Blueprint, request, jsonify
# from services.firebase_service import FirebaseService
# import uuid
# import time

# solo_routes = Blueprint("solo_routes", __name__)
# firebase = FirebaseService()


# # ---------------------------------------------
# # START SOLO GAME
# # ---------------------------------------------
# @solo_routes.route("/start-game", methods=["POST"])
# def start_game():
#     data = request.get_json()
#     username = data.get("username")

#     if not username:
#         return jsonify({"error": "Username is required"}), 400

#     # Create unique session/game room ID
#     session_id = str(uuid.uuid4())

#     # TEMP placeholders (will be replaced by GPT)
#     story = "AI is preparing your crime story..."
#     suspects = ["Person A", "Person B", "Person C", "Person D"]
#     culprit = "Person B"   # TEMP â€“ later AI randomly selects
#     clues = {
#         "clue1": "First clue will be generated by AI.",
#         "clue2": None   # reserved for later
#     }

#     game_data = {
#         "player": username,
#         "session_id": session_id,
#         "story": story,
#         "suspects": suspects,
#         "culprit": culprit,
#         "clues": clues,
#         "created_at": int(time.time()),
#         "status": "in_progress"
#     }

#     # Save game into Firebase
#     firebase.set(f"/solo_games/{session_id}", game_data)

#     return jsonify(game_data), 200


# # ---------------------------------------------
# # AI CHAT (placeholder, will use GPT later)
# # ---------------------------------------------
# @solo_routes.route("/chat", methods=["POST"])
# def chat():
#     data = request.get_json()
#     message = data.get("message")
#     session_id = data.get("session_id")

#     if not message or not session_id:
#         return jsonify({"error": "Missing message or session_id"}), 400

#     # TEMP: AI fake reply (GPT-2 will replace this)
#     reply = f"AI Response: I can't reveal the culprit, but here's context about your question: {message}"

#     return jsonify({"reply": reply}), 200


# # ---------------------------------------------
# # GET CLUE #2 WHEN TIMER ENDS
# # ---------------------------------------------
# @solo_routes.route("/clue2", methods=["POST"])
# def clue2():
#     data = request.get_json()
#     session_id = data.get("session_id")

#     if not session_id:
#         return jsonify({"error": "Session ID required"}), 400

#     # TEMP placeholder for clue2
#     clue_text = "Second clue: AI generated clue #2 will appear here."

#     firebase.update(f"/solo_games/{session_id}/clues", {"clue2": clue_text})

#     return jsonify({"clue2": clue_text}), 200


# # ---------------------------------------------
# # VOTING â€“ check if correct
# # ---------------------------------------------
# @solo_routes.route("/vote", methods=["POST"])
# def vote():
#     data = request.get_json()
#     session_id = data.get("session_id")
#     guess = data.get("guess")
#     username = data.get("username")

#     if not all([session_id, guess, username]):
#         return jsonify({"error": "Missing data"}), 400

#     game = firebase.get(f"/solo_games/{session_id}")
#     if not game:
#         return jsonify({"error": "Game not found"}), 404

#     correct = game["culprit"] == guess

#     # Update user stats
#     path = f"/users/{username}"
#     user = firebase.get(path)

#     if not user:
#         return jsonify({"error": "User not found"}), 404

#     user["total_games"] += 1
#     if correct:
#         user["total_wins"] += 1
#     else:
#         user["total_losses"] += 1

#     firebase.set(path, user)

#     return jsonify({"correct": correct}), 200


# # ---------------------------------------------
# # LEAVE GAME (invalid game)
# # ---------------------------------------------
# @solo_routes.route("/leave", methods=["POST"])
# def leave():
#     data = request.get_json()
#     session_id = data.get("session_id")

#     if not session_id:
#         return jsonify({"error": "Session ID required"}), 400

#     firebase.update(f"/solo_games/{session_id}", {"status": "abandoned"})

#     return jsonify({"message": "Game ended without result"}), 200



# from flask import Blueprint, request, jsonify
# from services.firebase_service import FirebaseService
# import uuid
# import time
# from ai.generator import (
#     generate_crime_story,
#     extract_suspects,
#     pick_culprit,
#     generate_clue,
#     generate_chat_reply,
#     generate_final_reveal,
# )

# solo_routes = Blueprint("solo_routes", __name__)
# firebase = FirebaseService()


# # ---------------------------------------------------
# # START SOLO GAME (NOW WITH REAL AI)
# # ---------------------------------------------------
# @solo_routes.route("/start-game", methods=["POST"])
# def start_game():
#     data = request.get_json()
#     username = data.get("username")

#     if not username:
#         return jsonify({"error": "Username is required"}), 400

#     # Session ID
#     session_id = str(uuid.uuid4())

#     # ---- AI GENERATION ----
#     story = generate_crime_story()

#     suspects = extract_suspects(story)
#     if len(suspects) < 2:
#         suspects = ["Unknown 1", "Unknown 2", "Unknown 3"]

#     culprit = pick_culprit(suspects)

#     clue1 = generate_clue(story, culprit, strength="weak")
#     clue2 = generate_clue(story, culprit, strength="strong")

#     # Save game to Firebase
#     game_data = {
#         "player": username,
#         "session_id": session_id,
#         "story": story,
#         "suspects": suspects,
#         "culprit": culprit,
#         "clues": {
#             "clue1": clue1,
#             "clue2": clue2
#         },
#         "created_at": int(time.time()),
#         "status": "in_progress"
#     }

#     firebase.set(f"/solo_games/{session_id}", game_data)

#     # Frontend will use these:
#     return jsonify({
#         "session_id": session_id,
#         "story": story,
#         "suspects": suspects,
#         "clue1": clue1
#     }), 200


# # ---------------------------------------------------
# # AI CHAT
# # ---------------------------------------------------
# @solo_routes.route("/chat", methods=["POST"])
# def chat():
#     data = request.get_json()
#     message = data.get("message")
#     session_id = data.get("session_id")

#     if not message or not session_id:
#         return jsonify({"error": "Missing message or session_id"}), 400

#     # Get session
#     session = firebase.get(f"/solo_games/{session_id}")
#     if not session:
#         return jsonify({"error": "Session not found"}), 404

#     story = session["story"]
#     suspects = session["suspects"]

#     # AI reply
#     reply = generate_chat_reply(story, suspects, message)

#     return jsonify({"reply": reply}), 200


# # ---------------------------------------------------
# # UNLOCK CLUE 2
# # ---------------------------------------------------
# @solo_routes.route("/clue2", methods=["POST"])
# def clue2():
#     data = request.get_json()
#     session_id = data.get("session_id")

#     if not session_id:
#         return jsonify({"error": "Session ID required"}), 400

#     session = firebase.get(f"/solo_games/{session_id}")
#     if not session:
#         return jsonify({"error": "Game not found"}), 404

#     # clue2 is already generated during start-game
#     clue_text = session["clues"]["clue2"]

#     return jsonify({"clue2": clue_text}), 200


# # ---------------------------------------------------
# # PLAYER VOTE
# # ---------------------------------------------------
# @solo_routes.route("/vote", methods=["POST"])
# def vote():
#     data = request.get_json()
#     session_id = data.get("session_id")
#     guess = data.get("guess")
#     username = data.get("username")

#     if not all([session_id, guess, username]):
#         return jsonify({"error": "Missing data"}), 400

#     game = firebase.get(f"/solo_games/{session_id}")
#     if not game:
#         return jsonify({"error": "Game not found"}), 404

#     correct = game["culprit"] == guess

#     # Update player stats
#     path = f"/users/{username}"
#     user = firebase.get(path)

#     if not user:
#         return jsonify({"error": "User not found"}), 404

#     user["total_games"] += 1

#     if correct:
#         user["total_wins"] += 1
#     else:
#         user["total_losses"] += 1

#     firebase.set(path, user)

#     return jsonify({"correct": correct}), 200


# # ---------------------------------------------------
# # FINAL REVEAL (AI EXPLANATION)
# # ---------------------------------------------------
# @solo_routes.route("/reveal", methods=["POST"])
# def reveal():
#     data = request.get_json()
#     session_id = data.get("session_id")

#     if not session_id:
#         return jsonify({"error": "Missing session_id"}), 400

#     game = firebase.get(f"/solo_games/{session_id}")
#     if not game:
#         return jsonify({"error": "Game not found"}), 404

#     story = game["story"]
#     culprit = game["culprit"]

#     final_text = generate_final_reveal(story, culprit)

#     return jsonify({
#         "culprit": culprit,
#         "final_text": final_text
#     }), 200


# # ---------------------------------------------------
# # PLAYER LEAVES GAME
# # ---------------------------------------------------
# @solo_routes.route("/leave", methods=["POST"])
# def leave():
#     data = request.get_json()
#     session_id = data.get("session_id")

#     if not session_id:
#         return jsonify({"error": "Session ID required"}), 400

#     firebase.update(f"/solo_games/{session_id}", {"status": "abandoned"})

#     return jsonify({"message": "Game ended without result"}), 200



from flask import Blueprint, request, jsonify
from services.firebase_service import FirebaseService
import uuid
import time
import random

from ai.generator import (
    generate_crime_story,
    extract_suspects,
    pick_culprit,
    generate_clue,
    generate_chat_reply,
    generate_final_reveal
)

solo_routes = Blueprint("solo_routes", __name__)
firebase = FirebaseService()


# ---------------------------------------------------
# START SOLO GAME
# ---------------------------------------------------
# @solo_routes.route("/start-game", methods=["POST"])
# def start_game():
#     data = request.get_json()
#     username = data.get("username")

#     if not username:
#         return jsonify({"error": "Username is required"}), 400

#     session_id = str(uuid.uuid4())

#     # AI story generation
#     story = generate_crime_story()
#     suspects = extract_suspects(story)
    
    
#         # Save memory so names & settings don't repeat globally
#     memory = firebase.get("/story_memory") or {
#         "used_names": [], "used_settings": [], "used_themes": []
#     }

#     # Append new data
#     memory["used_names"].extend(suspects)

#     # Store blueprint-based metadata if needed
#     # but since generator used blueprint internally, skip 

#     # Limit stored history
#     memory["used_names"] = memory["used_names"][-300:]

#     firebase.set("/story_memory", memory)

    
#     culprit = pick_culprit(suspects)

#     clue1 = generate_clue(story, culprit, "weak")
#     clue2 = generate_clue(story, culprit, "strong")

#     # SAVE to Firebase
#     game_data = {
#         "player": username,
#         "session_id": session_id,
#         "story": story,
#         "suspects": suspects,
#         "culprit": culprit,
#         "clues": {"clue1": clue1, "clue2": clue2},
#         "created_at": int(time.time()),
#         "status": "in_progress"
#     }

#     firebase.set(f"/solo_games/{session_id}", game_data)

#     return jsonify({
#         "session_id": session_id,
#         "story": story,
#         "suspects": suspects,
#         "clue1": clue1,
#         "clues": {"clue1": clue1, "clue2": None}
#     }), 200


# @solo_routes.route("/start-game", methods=["POST"])
# def start_game():
#     data = request.get_json()
#     username = data.get("username")

#     if not username:
#         return jsonify({"error": "Username is required"}), 400

#     session_id = str(uuid.uuid4())

#     # AI story + blueprint
#     story, blueprint = generate_crime_story()
#     suspects = extract_suspects(story)

#     # === MEMORY SYSTEM UPDATE ===
#     memory = firebase.get("/story_memory") or {
#         "used_names": [], "used_settings": [], "used_themes": []
#     }

#     memory["used_names"].extend(suspects)
#     memory["used_settings"].append(blueprint["setting"])
#     memory["used_themes"].append(blueprint["theme"])

#     # Trim history (keeps DB small)
#     memory["used_names"] = memory["used_names"][-300:]
#     memory["used_settings"] = memory["used_settings"][-60:]
#     memory["used_themes"] = memory["used_themes"][-40:]

#     firebase.set("/story_memory", memory)

#     # Continue normal flow
#     culprit = pick_culprit(suspects)
#     clue1 = generate_clue(story, culprit, "weak")
#     clue2 = generate_clue(story, culprit, "strong")

#     game_data = {
#         "player": username,
#         "session_id": session_id,
#         "story": story,
#         "suspects": suspects,
#         "culprit": culprit,
#         "clues": {"clue1": clue1, "clue2": clue2},
#         "created_at": int(time.time()),
#         "status": "in_progress"
#     }

#     firebase.set(f"/solo_games/{session_id}", game_data)

#     return jsonify({
#         "session_id": session_id,
#         "story": story,
#         "suspects": suspects,
#         "clue1": clue1,
#         "clues": {"clue1": clue1, "clue2": None}
#     }), 200

@solo_routes.route("/start-game", methods=["POST"])
def start_game():
    data = request.get_json()
    username = data.get("username")

    if not username:
        return jsonify({"error": "Username is required"}), 400

    session_id = str(uuid.uuid4())

    # ðŸ”¥ NEW: Smart generator (prevents repeated suspects/settings/themes)
    story = generate_crime_story()

    # Extract suspects from generated story
    suspects = extract_suspects(story)

    # Safety fallback: ensure at least 4 suspects
    if len(suspects) < 4:
        fallback = [
            "Ava Carter", "Ethan Hayes", "Liam Brooks",
            "Mason Reed", "Olivia Turner", "Noah Scott",
            "Sophie Lane", "Logan Pierce", "Harper Cole", "Zara Quinn"
        ]
        suspects = random.sample(fallback, 4)

    # Pick a random culprit from suspects list
    culprit = pick_culprit(suspects)

    # Generate dynamic clues based on culprit + story
    clue1 = generate_clue(story, culprit, "weak")
    clue2 = generate_clue(story, culprit, "strong")

    # ------- SAVE GAME DATA TO FIREBASE -------
    game_data = {
        "player": username,
        "session_id": session_id,
        "story": story,
        "suspects": suspects,
        "culprit": culprit,
        "clues": {
            "clue1": clue1,
            "clue2": clue2
        },
        "votes": [],
        "created_at": int(time.time()),
        "status": "in_progress"
    }

    firebase.set(f"/solo_games/{session_id}", game_data)

    # ------- SEND ONLY WHAT FRONTEND NEEDS FIRST -------
    return jsonify({
        "session_id": session_id,
        "story": story,
        "suspects": suspects,
        "clue1": clue1,        # immediate first clue
        "clues": {"clue1": clue1, "clue2": None}  # reveal clue2 later
    }), 200


# ---------------------------------------------------
# AI CHAT
# ---------------------------------------------------
@solo_routes.route("/chat", methods=["POST"])
def chat():
    data = request.get_json()
    message = data.get("message")
    session_id = data.get("session_id")

    if not message or not session_id:
        return jsonify({"error": "Missing data"}), 400

    game = firebase.get(f"/solo_games/{session_id}")
    if not game:
        return jsonify({"error": "Session not found"}), 404

    reply = generate_chat_reply(game["story"], game["suspects"], message)
    return jsonify({"reply": reply}), 200


# ---------------------------------------------------
# UNLOCK CLUE 2
# ---------------------------------------------------
@solo_routes.route("/clue2", methods=["POST"])
def clue2():
    data = request.get_json()
    session_id = data.get("session_id")

    game = firebase.get(f"/solo_games/{session_id}")
    if not game:
        return jsonify({"error": "Game not found"}), 404

    return jsonify({"clue2": game["clues"]["clue2"]}), 200


# ---------------------------------------------------
# PLAYER VOTE
# ---------------------------------------------------
# @solo_routes.route("/vote", methods=["POST"])
# def vote():
#     data = request.get_json()
#     session_id = data.get("session_id")
#     guess = data.get("guess")
#     username = data.get("username")

#     game = firebase.get(f"/solo_games/{session_id}")
#     if not game:
#         return jsonify({"error": "Game not found"}), 404

#     correct = (guess == game["culprit"])

#     # update stats
#     user_path = f"/users/{username}"
#     user = firebase.get(user_path)

#     user["total_games"] += 1
#     if correct:
#         user["total_wins"] += 1
#     else:
#         user["total_losses"] += 1

#     firebase.set(user_path, user)

#     return jsonify({"correct": correct}), 200

# @solo_routes.route("/vote", methods=["POST"])
# def vote():
#     data = request.get_json()
#     session_id = data.get("session_id")
#     guess = data.get("guess")
#     username = data.get("username")

#     game = firebase.get(f"/solo_games/{session_id}")
#     if not game:
#         return jsonify({"error": "Game not found"}), 404

#     # Initialize vote history if missing
#     votes = game.get("votes", [])
#     attempt_num = len(votes) + 1  # 1 or 2

#     if attempt_num > 2:
#         return jsonify({"error": "No more votes allowed"}), 400

#     correct = (guess == game["culprit"])

#     # Record attempt
#     votes.append({"guess": guess, "correct": correct})
#     firebase.update(f"/solo_games/{session_id}", {"votes": votes})

#     # If first attempt wrong â†’ allow second attempt but don't end game
#     if attempt_num == 1 and not correct:
#         return jsonify({
#             "correct": False,
#             "attempt": 1,
#             "message": "First guess wrong. You may try again."
#         }), 200

#     # If second attempt wrong â†’ player loses immediately
#     if attempt_num == 2 and not correct:
#         # update user stats
#         user_path = f"/users/{username}"
#         user = firebase.get(user_path)
#         user["total_games"] += 1
#         user["total_losses"] += 1
#         firebase.set(user_path, user)

#         return jsonify({
#             "correct": False,
#             "attempt": 2,
#             "final": True
#         }), 200

#     # If any correct guess â†’ win immediately
#     if correct:
#         user_path = f"/users/{username}"
#         user = firebase.get(user_path)
#         user["total_games"] += 1
#         user["total_wins"] += 1
#         firebase.set(user_path, user)

#         return jsonify({
#             "correct": True,
#             "attempt": attempt_num,
#             "final": True
#         }), 200

@solo_routes.route("/vote", methods=["POST"])
def vote():
    data = request.get_json()
    session_id = data.get("session_id")
    guess = data.get("guess")
    username = data.get("username")

    game = firebase.get(f"/solo_games/{session_id}")
    if not game:
        return jsonify({"error": "Game not found"}), 404

    elapsed = int(time.time()) - game["created_at"]

    if elapsed < 300 and len(game.get("votes", [])) == 0:
        return jsonify({"error": "too_soon", "seconds_left": 300 - elapsed}), 403

    votes = game.get("votes", [])
    attempt = len(votes) + 1
    if attempt > 2:
        return jsonify({"error": "No more attempts"}), 400

    correct = (guess == game["culprit"])
    votes.append({"guess": guess, "correct": correct})
    firebase.update(f"/solo_games/{session_id}", {"votes": votes})

    user_path = f"/users/{username}"
    user = firebase.get(user_path)

    # WIN condition (any correct vote)
    if correct:
        user["total_games"] += 1
        user["total_wins"] += 1
        firebase.set(user_path, user)

        firebase.push(f"/history/{username}", {
            "result": "win",
            "timestamp": int(time.time())
        })

        firebase.update(f"/solo_games/{session_id}", {"status": "finished"})

        return jsonify({"correct": True, "final": True, "message": "Correct! Case solved."}), 200


    # WRONG FIRST VOTE â†’ unlock clue & allow retry
    if attempt == 1:
        return jsonify({
            "correct": False,
            "attempt": 1,
            "final": False,
            "unlock_clue": True,
            "message": "Wrong first guess. You still have one final chance."
        }), 200

    # WRONG SECOND VOTE â†’ LOSE
    if attempt == 2:
        user["total_games"] += 1
        user["total_losses"] += 1
        firebase.set(user_path, user)

        # ðŸ”¥ FIX: record loss in history
        firebase.push(f"/history/{username}", {
            "result": "loss",
            "timestamp": int(time.time())
        })

        firebase.update(f"/solo_games/{session_id}", {"status": "finished"})

        return jsonify({
            "correct": False,
            "attempt": 2,
            "final": True,
            "message": "Wrong again. The case is lost."
        }), 200




# ---------------------------------------------------
# FINAL REVEAL
# ---------------------------------------------------
@solo_routes.route("/reveal", methods=["POST"])
def reveal():
    data = request.get_json()
    session_id = data.get("session_id")

    game = firebase.get(f"/solo_games/{session_id}")
    if not game:
        return jsonify({"error": "Game not found"}), 404

    final_text = generate_final_reveal(game["story"], game["culprit"])
    return jsonify({    
        "culprit": game["culprit"],
        "final_text": final_text
    }), 200


# ---------------------------------------------------
# LEAVE GAME
# ---------------------------------------------------
# @solo_routes.route("/leave", methods=["POST"])
# def leave():
#     session_id = request.json.get("session_id")

#     firebase.update(f"/solo_games/{session_id}", {"status": "abandoned"})
#     return jsonify({"message": "Game ended without result"}), 200
@solo_routes.route("/leave", methods=["POST"])
def leave():
    session_id = request.json.get("session_id")
    firebase.update(f"/solo_games/{session_id}", {"status": "abandoned", "counted": False})
    return jsonify({"message": "Game ended without result"}), 200

