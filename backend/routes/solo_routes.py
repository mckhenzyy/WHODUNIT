# from flask import Blueprint, request, jsonify
# from services.firebase_service import FirebaseService
# import uuid
# import time

# solo_routes = Blueprint("solo_routes", __name__)
# firebase = FirebaseService()


# # ---------------------------------------------
# # START SOLO GAME
# # ---------------------------------------------
# @solo_routes.route("/start-game", methods=["POST"])
# def start_game():
#     data = request.get_json()
#     username = data.get("username")

#     if not username:
#         return jsonify({"error": "Username is required"}), 400

#     # Create unique session/game room ID
#     session_id = str(uuid.uuid4())

#     # TEMP placeholders (will be replaced by GPT)
#     story = "AI is preparing your crime story..."
#     suspects = ["Person A", "Person B", "Person C", "Person D"]
#     culprit = "Person B"   # TEMP ‚Äì later AI randomly selects
#     clues = {
#         "clue1": "First clue will be generated by AI.",
#         "clue2": None   # reserved for later
#     }

#     game_data = {
#         "player": username,
#         "session_id": session_id,
#         "story": story,
#         "suspects": suspects,
#         "culprit": culprit,
#         "clues": clues,
#         "created_at": int(time.time()),
#         "status": "in_progress"
#     }

#     # Save game into Firebase
#     firebase.set(f"/solo_games/{session_id}", game_data)

#     return jsonify(game_data), 200


# # ---------------------------------------------
# # AI CHAT (placeholder, will use GPT later)
# # ---------------------------------------------
# @solo_routes.route("/chat", methods=["POST"])
# def chat():
#     data = request.get_json()
#     message = data.get("message")
#     session_id = data.get("session_id")

#     if not message or not session_id:
#         return jsonify({"error": "Missing message or session_id"}), 400

#     # TEMP: AI fake reply (GPT-2 will replace this)
#     reply = f"AI Response: I can't reveal the culprit, but here's context about your question: {message}"

#     return jsonify({"reply": reply}), 200


# # ---------------------------------------------
# # GET CLUE #2 WHEN TIMER ENDS
# # ---------------------------------------------
# @solo_routes.route("/clue2", methods=["POST"])
# def clue2():
#     data = request.get_json()
#     session_id = data.get("session_id")

#     if not session_id:
#         return jsonify({"error": "Session ID required"}), 400

#     # TEMP placeholder for clue2
#     clue_text = "Second clue: AI generated clue #2 will appear here."

#     firebase.update(f"/solo_games/{session_id}/clues", {"clue2": clue_text})

#     return jsonify({"clue2": clue_text}), 200


# # ---------------------------------------------
# # VOTING ‚Äì check if correct
# # ---------------------------------------------
# @solo_routes.route("/vote", methods=["POST"])
# def vote():
#     data = request.get_json()
#     session_id = data.get("session_id")
#     guess = data.get("guess")
#     username = data.get("username")

#     if not all([session_id, guess, username]):
#         return jsonify({"error": "Missing data"}), 400

#     game = firebase.get(f"/solo_games/{session_id}")
#     if not game:
#         return jsonify({"error": "Game not found"}), 404

#     correct = game["culprit"] == guess

#     # Update user stats
#     path = f"/users/{username}"
#     user = firebase.get(path)

#     if not user:
#         return jsonify({"error": "User not found"}), 404

#     user["total_games"] += 1
#     if correct:
#         user["total_wins"] += 1
#     else:
#         user["total_losses"] += 1

#     firebase.set(path, user)

#     return jsonify({"correct": correct}), 200


# # ---------------------------------------------
# # LEAVE GAME (invalid game)
# # ---------------------------------------------
# @solo_routes.route("/leave", methods=["POST"])
# def leave():
#     data = request.get_json()
#     session_id = data.get("session_id")

#     if not session_id:
#         return jsonify({"error": "Session ID required"}), 400

#     firebase.update(f"/solo_games/{session_id}", {"status": "abandoned"})

#     return jsonify({"message": "Game ended without result"}), 200



# from flask import Blueprint, request, jsonify
# from services.firebase_service import FirebaseService
# import uuid
# import time
# from ai.generator import (
#     generate_crime_story,
#     extract_suspects,
#     pick_culprit,
#     generate_clue,
#     generate_chat_reply,
#     generate_final_reveal,
# )

# solo_routes = Blueprint("solo_routes", __name__)
# firebase = FirebaseService()


# # ---------------------------------------------------
# # START SOLO GAME (NOW WITH REAL AI)
# # ---------------------------------------------------
# @solo_routes.route("/start-game", methods=["POST"])
# def start_game():
#     data = request.get_json()
#     username = data.get("username")

#     if not username:
#         return jsonify({"error": "Username is required"}), 400

#     # Session ID
#     session_id = str(uuid.uuid4())

#     # ---- AI GENERATION ----
#     story = generate_crime_story()

#     suspects = extract_suspects(story)
#     if len(suspects) < 2:
#         suspects = ["Unknown 1", "Unknown 2", "Unknown 3"]

#     culprit = pick_culprit(suspects)

#     clue1 = generate_clue(story, culprit, strength="weak")
#     clue2 = generate_clue(story, culprit, strength="strong")

#     # Save game to Firebase
#     game_data = {
#         "player": username,
#         "session_id": session_id,
#         "story": story,
#         "suspects": suspects,
#         "culprit": culprit,
#         "clues": {
#             "clue1": clue1,
#             "clue2": clue2
#         },
#         "created_at": int(time.time()),
#         "status": "in_progress"
#     }

#     firebase.set(f"/solo_games/{session_id}", game_data)

#     # Frontend will use these:
#     return jsonify({
#         "session_id": session_id,
#         "story": story,
#         "suspects": suspects,
#         "clue1": clue1
#     }), 200


# # ---------------------------------------------------
# # AI CHAT
# # ---------------------------------------------------
# @solo_routes.route("/chat", methods=["POST"])
# def chat():
#     data = request.get_json()
#     message = data.get("message")
#     session_id = data.get("session_id")

#     if not message or not session_id:
#         return jsonify({"error": "Missing message or session_id"}), 400

#     # Get session
#     session = firebase.get(f"/solo_games/{session_id}")
#     if not session:
#         return jsonify({"error": "Session not found"}), 404

#     story = session["story"]
#     suspects = session["suspects"]

#     # AI reply
#     reply = generate_chat_reply(story, suspects, message)

#     return jsonify({"reply": reply}), 200


# # ---------------------------------------------------
# # UNLOCK CLUE 2
# # ---------------------------------------------------
# @solo_routes.route("/clue2", methods=["POST"])
# def clue2():
#     data = request.get_json()
#     session_id = data.get("session_id")

#     if not session_id:
#         return jsonify({"error": "Session ID required"}), 400

#     session = firebase.get(f"/solo_games/{session_id}")
#     if not session:
#         return jsonify({"error": "Game not found"}), 404

#     # clue2 is already generated during start-game
#     clue_text = session["clues"]["clue2"]

#     return jsonify({"clue2": clue_text}), 200


# # ---------------------------------------------------
# # PLAYER VOTE
# # ---------------------------------------------------
# @solo_routes.route("/vote", methods=["POST"])
# def vote():
#     data = request.get_json()
#     session_id = data.get("session_id")
#     guess = data.get("guess")
#     username = data.get("username")

#     if not all([session_id, guess, username]):
#         return jsonify({"error": "Missing data"}), 400

#     game = firebase.get(f"/solo_games/{session_id}")
#     if not game:
#         return jsonify({"error": "Game not found"}), 404

#     correct = game["culprit"] == guess

#     # Update player stats
#     path = f"/users/{username}"
#     user = firebase.get(path)

#     if not user:
#         return jsonify({"error": "User not found"}), 404

#     user["total_games"] += 1

#     if correct:
#         user["total_wins"] += 1
#     else:
#         user["total_losses"] += 1

#     firebase.set(path, user)

#     return jsonify({"correct": correct}), 200


# # ---------------------------------------------------
# # FINAL REVEAL (AI EXPLANATION)
# # ---------------------------------------------------
# @solo_routes.route("/reveal", methods=["POST"])
# def reveal():
#     data = request.get_json()
#     session_id = data.get("session_id")

#     if not session_id:
#         return jsonify({"error": "Missing session_id"}), 400

#     game = firebase.get(f"/solo_games/{session_id}")
#     if not game:
#         return jsonify({"error": "Game not found"}), 404

#     story = game["story"]
#     culprit = game["culprit"]

#     final_text = generate_final_reveal(story, culprit)

#     return jsonify({
#         "culprit": culprit,
#         "final_text": final_text
#     }), 200


# # ---------------------------------------------------
# # PLAYER LEAVES GAME
# # ---------------------------------------------------
# @solo_routes.route("/leave", methods=["POST"])
# def leave():
#     data = request.get_json()
#     session_id = data.get("session_id")

#     if not session_id:
#         return jsonify({"error": "Session ID required"}), 400

#     firebase.update(f"/solo_games/{session_id}", {"status": "abandoned"})

#     return jsonify({"message": "Game ended without result"}), 200



from flask import Blueprint, request, jsonify
from services.firebase_service import FirebaseService
import uuid
import time
import random, re

from ai.generator import (
    generate_crime_story,
    extract_suspects,
    pick_culprit,
    generate_clue,
    generate_chat_reply,
    generate_final_reveal
)

solo_routes = Blueprint("solo_routes", __name__)
firebase = FirebaseService()




def extract_setting(story):
    match = re.search(r"(in|at|inside|near|on)\s([A-Za-z\s]+)", story)
    return match.group(2).strip() if match else None

def update_leaderboard(username, streak):
    path = "/leaderboard"
    
    leaderboard = firebase.get(path) or {}

    # Always overwrite existing entry
    leaderboard[username] = {
        "username": username,
        "streak": streak,
        "updated_at": int(time.time())
    }

    # Sort
    sorted_list = sorted(
        leaderboard.values(),
        key=lambda x: (-x["streak"], x["updated_at"])
    )

    # Keep only top 10
    final_list = sorted_list[:10]

    # Rebuild dictionary form
    final_dict = {entry["username"]: entry for entry in final_list}

    # Force-save
    firebase.set(path, final_dict)

    return final_dict

# ---------------------------------------------------
# START SOLO GAME
# ---------------------------------------------------
# @solo_routes.route("/start-game", methods=["POST"])
# def start_game():
#     data = request.get_json()
#     username = data.get("username")

#     if not username:
#         return jsonify({"error": "Username is required"}), 400

#     session_id = str(uuid.uuid4())

#     # AI story generation
#     story = generate_crime_story()
#     suspects = extract_suspects(story)
    
    
#         # Save memory so names & settings don't repeat globally
#     memory = firebase.get("/story_memory") or {
#         "used_names": [], "used_settings": [], "used_themes": []
#     }

#     # Append new data
#     memory["used_names"].extend(suspects)

#     # Store blueprint-based metadata if needed
#     # but since generator used blueprint internally, skip 

#     # Limit stored history
#     memory["used_names"] = memory["used_names"][-300:]

#     firebase.set("/story_memory", memory)

    
#     culprit = pick_culprit(suspects)

#     clue1 = generate_clue(story, culprit, "weak")
#     clue2 = generate_clue(story, culprit, "strong")

#     # SAVE to Firebase
#     game_data = {
#         "player": username,
#         "session_id": session_id,
#         "story": story,
#         "suspects": suspects,
#         "culprit": culprit,
#         "clues": {"clue1": clue1, "clue2": clue2},
#         "created_at": int(time.time()),
#         "status": "in_progress"
#     }

#     firebase.set(f"/solo_games/{session_id}", game_data)

#     return jsonify({
#         "session_id": session_id,
#         "story": story,
#         "suspects": suspects,
#         "clue1": clue1,
#         "clues": {"clue1": clue1, "clue2": None}
#     }), 200


# @solo_routes.route("/start-game", methods=["POST"])
# def start_game():
#     data = request.get_json()
#     username = data.get("username")

#     if not username:
#         return jsonify({"error": "Username is required"}), 400

#     session_id = str(uuid.uuid4())

#     # AI story + blueprint
#     story, blueprint = generate_crime_story()
#     suspects = extract_suspects(story)

#     # === MEMORY SYSTEM UPDATE ===
#     memory = firebase.get("/story_memory") or {
#         "used_names": [], "used_settings": [], "used_themes": []
#     }

#     memory["used_names"].extend(suspects)
#     memory["used_settings"].append(blueprint["setting"])
#     memory["used_themes"].append(blueprint["theme"])

#     # Trim history (keeps DB small)
#     memory["used_names"] = memory["used_names"][-300:]
#     memory["used_settings"] = memory["used_settings"][-60:]
#     memory["used_themes"] = memory["used_themes"][-40:]

#     firebase.set("/story_memory", memory)

#     # Continue normal flow
#     culprit = pick_culprit(suspects)
#     clue1 = generate_clue(story, culprit, "weak")
#     clue2 = generate_clue(story, culprit, "strong")

#     game_data = {
#         "player": username,
#         "session_id": session_id,
#         "story": story,
#         "suspects": suspects,
#         "culprit": culprit,
#         "clues": {"clue1": clue1, "clue2": clue2},
#         "created_at": int(time.time()),
#         "status": "in_progress"
#     }

#     firebase.set(f"/solo_games/{session_id}", game_data)

#     return jsonify({
#         "session_id": session_id,
#         "story": story,
#         "suspects": suspects,
#         "clue1": clue1,
#         "clues": {"clue1": clue1, "clue2": None}
#     }), 200

# @solo_routes.route("/start-game", methods=["POST"])
# def start_game():
#     data = request.get_json()
#     username = data.get("username")

#     if not username:
#         return jsonify({"error": "Username is required"}), 400

#     session_id = str(uuid.uuid4())

#     # üî• NEW: Smart generator (prevents repeated suspects/settings/themes)
#     story = generate_crime_story()

#     # Extract suspects from generated story
#     suspects = extract_suspects(story)

#     # Safety fallback: ensure at least 4 suspects
#     if len(suspects) < 4:
#         fallback = [
#             "Ava Carter", "Ethan Hayes", "Liam Brooks",
#             "Mason Reed", "Olivia Turner", "Noah Scott",
#             "Sophie Lane", "Logan Pierce", "Harper Cole", "Zara Quinn"
#         ]
#         suspects = random.sample(fallback, 4)

#     # Pick a random culprit from suspects list
#     culprit = pick_culprit(suspects)

#     # Generate dynamic clues based on culprit + story
#     clue1 = generate_clue(story, culprit, "weak")
#     clue2 = generate_clue(story, culprit, "strong")

#     # ------- SAVE GAME DATA TO FIREBASE -------
#     game_data = {
#         "player": username,
#         "session_id": session_id,
#         "story": story,
#         "suspects": suspects,
#         "culprit": culprit,
#         "clues": {
#             "clue1": clue1,
#             "clue2": clue2
#         },
#         "votes": [],
#         "created_at": int(time.time()),
#         "status": "in_progress"
#     }

#     firebase.set(f"/solo_games/{session_id}", game_data)

#     # ------- SEND ONLY WHAT FRONTEND NEEDS FIRST -------
#     return jsonify({
#         "session_id": session_id,
#         "story": story,
#         "suspects": suspects,
#         "clue1": clue1,        # immediate first clue
#         "clues": {"clue1": clue1, "clue2": None}  # reveal clue2 later
#     }), 200



@solo_routes.route("/start-game", methods=["POST"])
def start_game():
    data = request.get_json()
    username = data.get("username")

    if not username:
        return jsonify({"error": "Username is required"}), 400

    session_id = str(uuid.uuid4())

    # --- Load player history to prevent duplicates ---
    history = firebase.get(f"/case_history/{username}") or {}

    played_settings = {entry.get("setting") for entry in history.values() if entry.get("setting")}
    played_suspects = {sus for entry in history.values() for sus in entry.get("suspects", [])}
    played_hashes = {entry.get("story_hash") for entry in history.values()}

    # --- Try generating a UNIQUE story ---
    attempts = 0
    suspects = []
    story = None
    story_setting = None

    while attempts < 6:  # try up to 6 times for uniqueness
        story = generate_crime_story()
        story_hash = hash(story)
        suspects = extract_suspects(story)
        story_setting = extract_setting(story)

        # Check if story is unique based on:
        # - story hash
        # - suspects uniqueness
        # - setting uniqueness
        if (story_hash not in played_hashes 
            and not (set(suspects) & played_suspects)
            and story_setting not in played_settings):
            break

        attempts += 1

    # fallback if uniqueness failed
    if len(suspects) < 4:
        fallback = [
            "Ava Carter", "Ethan Hayes", "Liam Brooks",
            "Mason Reed", "Olivia Turner", "Noah Scott",
            "Sophie Lane", "Logan Pierce", "Harper Cole", "Zara Quinn"
        ]
        suspects = random.sample(fallback, 4)

    culprit = pick_culprit(suspects)

    clue1 = generate_clue(story, culprit, "weak")
    clue2 = generate_clue(story, culprit, "strong")

    # ---- Save story session ----
    game_data = {
        "player": username,
        "session_id": session_id,
        "story": story,
        "suspects": suspects,
        "culprit": culprit,
        "clues": {
            "clue1": clue1,
            "clue2": clue2
        },
        "votes": [],
        "created_at": int(time.time()),
        "status": "in_progress"
    }

    firebase.set(f"/solo_games/{session_id}", game_data)

    return jsonify({
        "session_id": session_id,
        "story": story,
        "suspects": suspects,
        "clue1": clue1,
        "clues": {"clue1": clue1, "clue2": None}
    }), 200


# ---------------------------------------------------
# AI CHAT
# ---------------------------------------------------
@solo_routes.route("/chat", methods=["POST"])
def chat():
    data = request.get_json()
    message = data.get("message")
    session_id = data.get("session_id")

    if not message or not session_id:
        return jsonify({"error": "Missing data"}), 400

    game = firebase.get(f"/solo_games/{session_id}")
    if not game:
        return jsonify({"error": "Session not found"}), 404

    reply = generate_chat_reply(game["story"], game["suspects"], message)
    return jsonify({"reply": reply}), 200


# ---------------------------------------------------
# UNLOCK CLUE 2
# ---------------------------------------------------
@solo_routes.route("/clue2", methods=["POST"])
def clue2():
    data = request.get_json()
    session_id = data.get("session_id")

    game = firebase.get(f"/solo_games/{session_id}")
    if not game:
        return jsonify({"error": "Game not found"}), 404

    return jsonify({"clue2": game["clues"]["clue2"]}), 200


# ---------------------------------------------------
# PLAYER VOTE
# ---------------------------------------------------
# @solo_routes.route("/vote", methods=["POST"])
# def vote():
#     data = request.get_json()
#     session_id = data.get("session_id")
#     guess = data.get("guess")
#     username = data.get("username")

#     game = firebase.get(f"/solo_games/{session_id}")
#     if not game:
#         return jsonify({"error": "Game not found"}), 404

#     correct = (guess == game["culprit"])

#     # update stats
#     user_path = f"/users/{username}"
#     user = firebase.get(user_path)

#     user["total_games"] += 1
#     if correct:
#         user["total_wins"] += 1
#     else:
#         user["total_losses"] += 1

#     firebase.set(user_path, user)

#     return jsonify({"correct": correct}), 200

# @solo_routes.route("/vote", methods=["POST"])
# def vote():
#     data = request.get_json()
#     session_id = data.get("session_id")
#     guess = data.get("guess")
#     username = data.get("username")

#     game = firebase.get(f"/solo_games/{session_id}")
#     if not game:
#         return jsonify({"error": "Game not found"}), 404

#     # Initialize vote history if missing
#     votes = game.get("votes", [])
#     attempt_num = len(votes) + 1  # 1 or 2

#     if attempt_num > 2:
#         return jsonify({"error": "No more votes allowed"}), 400

#     correct = (guess == game["culprit"])

#     # Record attempt
#     votes.append({"guess": guess, "correct": correct})
#     firebase.update(f"/solo_games/{session_id}", {"votes": votes})

#     # If first attempt wrong ‚Üí allow second attempt but don't end game
#     if attempt_num == 1 and not correct:
#         return jsonify({
#             "correct": False,
#             "attempt": 1,
#             "message": "First guess wrong. You may try again."
#         }), 200

#     # If second attempt wrong ‚Üí player loses immediately
#     if attempt_num == 2 and not correct:
#         # update user stats
#         user_path = f"/users/{username}"
#         user = firebase.get(user_path)
#         user["total_games"] += 1
#         user["total_losses"] += 1
#         firebase.set(user_path, user)

#         return jsonify({
#             "correct": False,
#             "attempt": 2,
#             "final": True
#         }), 200

#     # If any correct guess ‚Üí win immediately
#     if correct:
#         user_path = f"/users/{username}"
#         user = firebase.get(user_path)
#         user["total_games"] += 1
#         user["total_wins"] += 1
#         firebase.set(user_path, user)

#         return jsonify({
#             "correct": True,
#             "attempt": attempt_num,
#             "final": True
#         }), 200



@solo_routes.route("/history/<username>", methods=["GET"])
def get_history(username):
    history = firebase.get(f"/case_history/{username}") or {}

    formatted = sorted(
        history.values(),
        key=lambda x: -(x.get("timestamp") or 0)  # prevents crash on missing timestamps
    )

    return jsonify(formatted), 200



@solo_routes.route("/history/details", methods=["POST"])
def get_case_details():
    data = request.get_json()
    username = data.get("username")
    session_id = data.get("session_id")

    case = firebase.get(f"/case_history/{username}/{session_id}")
    if not case:
        return jsonify({"error": "Case not found"}), 404

    return jsonify(case), 200


# @solo_routes.route("/vote", methods=["POST"])
# def vote():
#     data = request.get_json()
#     session_id = data.get("session_id")
#     guess = data.get("guess")
#     username = data.get("username")

#     game = firebase.get(f"/solo_games/{session_id}")
#     if not game:
#         return jsonify({"error": "Game not found"}), 404

#     elapsed = int(time.time()) - game["created_at"]

#     if elapsed < 300 and len(game.get("votes", [])) == 0:
#         return jsonify({"error": "too_soon", "seconds_left": 300 - elapsed}), 403

#     votes = game.get("votes", [])
#     attempt = len(votes) + 1
#     if attempt > 2:
#         return jsonify({"error": "No more attempts"}), 400

#     correct = (guess == game["culprit"])
#     votes.append({"guess": guess, "correct": correct})
#     firebase.update(f"/solo_games/{session_id}", {"votes": votes})

#     user_path = f"/users/{username}"
#     user = firebase.get(user_path)


#     # WIN condition (any correct vote)
#     # if correct:
#     #     user["total_games"] += 1
#     #     user["total_wins"] += 1
#     #     firebase.set(user_path, user)

#     #     firebase.push(f"/history/{username}", {
#     #         "result": "win",
#     #         "timestamp": int(time.time())
#     #     })

#     #     firebase.update(f"/solo_games/{session_id}", {"status": "finished"})

#     #     return jsonify({"correct": True, "final": True, "message": "Correct! Case solved."}), 200

    
#     if correct:
#         user["total_games"] += 1
#         user["total_wins"] += 1

#         # WIN STREAK update
#         user["win_streak"] = user.get("win_streak", 0) + 1

#         firebase.set(user_path, user)

#         firebase.push(f"/history/{username}", {
#             "result": "win",
#             "timestamp": int(time.time())
#         })

#         firebase.update(f"/solo_games/{session_id}", {"status": "finished"})

#         # üèÜ UPDATE LEADERBOARD
#         update_leaderboard(username, user["win_streak"])

#         return jsonify({"correct": True, "final": True, "message": "Correct! Case solved."}), 200


#     # WRONG FIRST VOTE ‚Üí unlock clue & allow retry
#     if attempt == 1:
#         return jsonify({
#             "correct": False,
#             "attempt": 1,
#             "final": False,
#             "unlock_clue": True,
#             "message": "Wrong first guess. You still have one final chance."
#         }), 200

#     # WRONG SECOND VOTE ‚Üí LOSE
#     # if attempt == 2:
#     #     user["total_games"] += 1
#     #     user["total_losses"] += 1
#     #     firebase.set(user_path, user)

#     #     # üî• FIX: record loss in history
#     #     firebase.push(f"/history/{username}", {
#     #         "result": "loss",
#     #         "timestamp": int(time.time())
#     #     })

#     #     firebase.update(f"/solo_games/{session_id}", {"status": "finished"})

#     #     return jsonify({
#     #         "correct": False,
#     #         "attempt": 2,
#     #         "final": True,
#     #         "message": "Wrong again. The case is lost."
#     #     }), 200

    
#     if attempt == 2 and not correct:
#         user["total_games"] += 1
#         user["total_losses"] += 1

#         # LOSING resets win streak
#         user["win_streak"] = 0

#         firebase.set(user_path, user)

#         firebase.push(f"/history/{username}", {
#             "result": "loss",
#             "timestamp": int(time.time())
#         })

#         firebase.update(f"/solo_games/{session_id}", {"status": "finished"})

#         # üèÜ UPDATE LEADERBOARD (removes user if streak drops out of top 10)
#         update_leaderboard(username, user["win_streak"])

#         return jsonify({
#             "correct": False,
#             "attempt": 2,
#             "final": True,
#             "message": "Wrong again. The case is lost."
#         }), 200




@solo_routes.route("/vote", methods=["POST"])
def vote():
    data = request.get_json()
    session_id = data.get("session_id")
    guess = data.get("guess")
    username = data.get("username")

    game = firebase.get(f"/solo_games/{session_id}")
    if not game:
        return jsonify({"error": "Game not found"}), 404

    elapsed = int(time.time()) - game["created_at"]

    if elapsed < 300 and len(game.get("votes", [])) == 0:
        return jsonify({"error": "too_soon", "seconds_left": 300 - elapsed}), 403

    votes = game.get("votes", [])
    attempt = len(votes) + 1
    if attempt > 2:
        return jsonify({"error": "No more attempts allowed"}), 400

    correct = (guess == game["culprit"])
    votes.append({"guess": guess, "correct": correct})
    firebase.update(f"/solo_games/{session_id}", {"votes": votes})

    user_path = f"/users/{username}"
    user = firebase.get(user_path)

    # üéØ STORE CASE HISTORY (Win or Loss)
    case_record = {
        "title": game["story"].split("\n")[0],
        "culprit": game["culprit"],
        "result": "win" if correct else "loss",
        "timestamp": int(time.time()) // 1,
        "story": game["story"],
        "reveal": generate_final_reveal(game["story"], game["culprit"]),
        "suspects": game["suspects"],
        "setting": extract_setting(game["story"]),
        "story_hash": hash(game["story"])
    }

    firebase.set(f"/case_history/{username}/{session_id}", case_record)

    # üèÜ IF PLAYER WINS
    if correct:
        user["total_games"] += 1
        user["total_wins"] += 1

        # WIN streak update
        user["win_streak"] = user.get("win_streak", 0) + 1

        firebase.set(user_path, user)

        firebase.update(f"/solo_games/{session_id}", {"status": "finished"})

        # update leaderboard
        update_leaderboard(username, user["win_streak"])

        return jsonify({
            "correct": True,
            "final": True,
            "message": "Correct! Case solved."
        }), 200

    # ‚ùå WRONG FIRST ATTEMPT
    if attempt == 1:
        return jsonify({
            "correct": False,
            "attempt": 1,
            "final": False,
            "unlock_clue": True,
            "message": "Wrong first guess. You still have one final chance."
        }), 200

    # ‚ùå WRONG SECOND ATTEMPT ‚Üí LOSE
    if attempt == 2:
        user["total_games"] += 1
        user["total_losses"] += 1

        # Reset streak
        user["win_streak"] = 0

        firebase.set(user_path, user)

        firebase.update(f"/solo_games/{session_id}", {"status": "finished"})

        # update leaderboard
        update_leaderboard(username, user["win_streak"])

        return jsonify({
            "correct": False,
            "final": True,
            "message": "Wrong again. Case failed."
        }), 200



# ---------------------------------------------------
# FINAL REVEAL
# ---------------------------------------------------
# @solo_routes.route("/reveal", methods=["POST"])
# def reveal():
#     data = request.get_json()
#     session_id = data.get("session_id")

#     game = firebase.get(f"/solo_games/{session_id}")
#     if not game:
#         return jsonify({"error": "Game not found"}), 404

#     final_text = generate_final_reveal(game["story"], game["culprit"])
#     return jsonify({    
#         "culprit": game["culprit"],
#         "final_text": final_text
#     }), 200
@solo_routes.route("/reveal", methods=["POST"])
def reveal():
    data = request.get_json()
    session_id = data.get("session_id")

    game = firebase.get(f"/solo_games/{session_id}")
    if not game:
        return jsonify({"error": "Game not found"}), 404

    # üî• Prevent reveal if no vote yet
    if not game.get("votes") or len(game["votes"]) == 0:
        return jsonify({"error": "no_vote"}), 403

    final_text = generate_final_reveal(game["story"], game["culprit"])
    return jsonify({
        "culprit": game["culprit"],
        "final_text": final_text
    }), 200


# ---------------------------------------------------
# LEAVE GAME
# ---------------------------------------------------
# @solo_routes.route("/leave", methods=["POST"])
# def leave():
#     session_id = request.json.get("session_id")

#     firebase.update(f"/solo_games/{session_id}", {"status": "abandoned"})
#     return jsonify({"message": "Game ended without result"}), 200
@solo_routes.route("/leave", methods=["POST"])
def leave():
    session_id = request.json.get("session_id")
    firebase.update(f"/solo_games/{session_id}", {"status": "abandoned", "counted": False})
    return jsonify({"message": "Game ended without result"}), 200




@solo_routes.route("/leaderboard", methods=["GET"])
def leaderboard():
    leaderboard = firebase.get("/leaderboard") or {}
    
    sorted_list = sorted(
        leaderboard.values(),
        key=lambda x: (-x["streak"], x["updated_at"])
    )

    return jsonify(sorted_list), 200
